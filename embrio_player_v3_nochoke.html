<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Embrio Player v3.0</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #9bbc0f;  /* Verde GameBoy */
            --shadow-color-dark: #0f380f;  /* Verde oscuro GameBoy */
            --shadow-color-light: #8bac0f;  /* Verde claro GameBoy */
            --text-color: #0f380f;  /* Verde oscuro para texto */
            --accent-color: #306230;  /* Verde medio para acentos */
            --braun-yellow: #8bac0f;  /* Verde claro para botones */
            --braun-red: #306230;  /* Verde medio para alertas */
            --braun-orange: #306230;  /* Verde medio para acciones */
            --braun-grey: #0f380f;  /* Verde oscuro para elementos secundarios */
            --braun-darkgrey: #0f380f;  /* Verde oscuro para elementos terciarios */
            --braun-black: #0f380f;  /* Verde oscuro para texto principal */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
        }
        
        body {
            background-color: var(--bg-color);
            font-family: 'Press Start 2P', monospace;
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 15px;
            touch-action: none;
            max-width: 100vw;
            overflow-x: hidden;
            position: relative;
        }

        /* Efecto de scanlines */
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
        }

        /* Title Styles */
        .title-container {
            text-align: center;
            margin-bottom: 15px;
        }

        .title-container h1 {
            font-family: 'Press Start 2P', monospace;
            color: var(--text-color);
            font-size: 24px;
            text-shadow: 2px 2px 0 var(--shadow-color-dark);
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        /* Header Styles */
        .header-container {
            max-width: 100%;
            width: 100%;
            margin: 0 auto 20px;
        }

        .header-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .header-button {
            width: 100%;
            height: 50px;
            border-radius: 0;
            background: var(--bg-color);
            box-shadow: 4px 4px 0 var(--shadow-color-dark);
            border: 2px solid var(--shadow-color-dark);
            color: var(--text-color);
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-button:hover {
            background: var(--shadow-color-light);
        }

        .header-button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }
        
        .header-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .empty-space {
            width: 100%;
            height: 60px;
        }
        
        .header-row .header-button:first-child {
            color: var(--text-color);
        }
        
        /* BPM Button Long Press Styles */
        .bpm-button {
            transition: all 0.1s ease;
        }

        .bpm-button.long-pressing {
            background-color: var(--shadow-color-dark) !important;
            color: var(--bg-color) !important;
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }

        @keyframes bpmPulse {
            0%, 100% { 
                box-shadow: 2px 2px 0 var(--shadow-color-dark);
            }
            50% { 
                box-shadow: 4px 4px 0 var(--shadow-color-dark);
            }
        }
        
        /* Botón de Grabación (Record) */
        .btn-record {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-weight: normal;
        }
        
        /* Botón de Reproducción (Play) */
        .btn-play {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-weight: normal;
        }
        
        /* Estilos para el botón de carga de samples */
        .btn-load {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-weight: normal;
        }

        .btn-load:hover {
            background-color: var(--shadow-color-light);
        }
        
        /* Mantener color de texto en hover */
        .btn-record:hover, .btn-play:hover {
            background-color: var(--shadow-color-light);
        }
        
        .btn-record:hover {
            background-color: var(--shadow-color-dark);
        }
        
        .btn-play:hover {
            background-color: var(--shadow-color-dark);
        }
        
        .header-button i {
            margin-right: 8px;
        }
        
        /* Estilos para el botón de ayuda y su modal */
        .help-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--shadow-color-dark);
            color: var(--bg-color);
            border: none;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 5px;
        }

        .help-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            border: 2px solid var(--shadow-color-dark);
        }

        .help-content {
            position: relative;
            color: var(--shadow-color-dark);
        }

        .help-content h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .help-content ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .help-content li {
            margin: 5px 0;
            font-size: 12px;
        }

        .close-help {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--shadow-color-dark);
            color: var(--bg-color);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .section-title {
            font-family: 'Press Start 2P', monospace;
            color: var(--text-color);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            margin: 15px 0 10px;
        }
        
        .sequencer-row {
            position: relative;
        }
        
        .sequencer-row::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--shadow-color-dark);
            opacity: 0.2;
        }
        
        .tempo-controls {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            margin-top: 15px;
            gap: 10px;
        }
        
        .tempo-btn {
            font-size: 18px;
            font-weight: bold;
        }
        
        .tempo-display {
            font-family: 'Press Start 2P', monospace;
            color: var(--text-color);
            font-weight: 500;
            font-size: 12px;
        }
        
        .bar-label {
            color: var(--text-color);
            font-size: 10px;
        }
        
        .bar-btn {
            color: var(--text-color);
            font-weight: 500;
            font-size: 12px;
        }

        /* Bank Selector Styles */
        .bank-selector-row {
            margin-bottom: 15px;
        }
        
        .bank-btn {
            font-weight: 500;
            transition: all 0.2s ease;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        .bank-active {
            background-color: var(--shadow-color-dark);
            color: var(--bg-color) !important;
            font-weight: bold;
        }
        
        .bank-btn:hover:not(.bank-active) {
            background-color: var(--shadow-color-light);
        }

        /* Input Status Indicator */
        .input-status {
            display: none;
        }

        /* Main Content Styles */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .pad-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 100%;
        }

        .pad {
            position: relative;
            aspect-ratio: 1/1;
            border-radius: 0;
            background: var(--bg-color);
            box-shadow: 4px 4px 0 var(--shadow-color-dark);
            border: 2px solid var(--shadow-color-dark);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            overflow: hidden;
        }

        /* Pad Active/Playing Enhanced Feedback */
        .pad.pad-active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
            background-color: var(--shadow-color-dark) !important;
        }

        /* Estado para mover samples */
        .pad.selected-for-move {
            border: 3px solid var(--shadow-color-dark);
            background: var(--shadow-color-light);
            box-shadow: 0 0 20px var(--shadow-color-dark);
            animation: selectedPulse 1.5s steps(4) infinite;
        }

        @keyframes selectedPulse {
            0%, 100% { 
                border-color: var(--shadow-color-dark);
                box-shadow: 0 0 20px var(--shadow-color-dark);
            }
            50% { 
                border-color: var(--shadow-color-light);
                box-shadow: 0 0 25px var(--shadow-color-dark);
            }
        }

        /* Estados de Drag & Drop */
        .pad.drag-over {
            border: 3px dashed var(--shadow-color-dark);
            background: var(--shadow-color-light);
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }

        .pad.drag-valid {
            border-color: var(--shadow-color-dark);
            background: var(--shadow-color-light);
        }

        /* Sample Slicer Modal */
        .slicer-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 56, 15, 0.8);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .slicer-panel {
            background: var(--bg-color);
            border: 4px solid var(--shadow-color-dark);
            box-shadow: 8px 8px 0 var(--shadow-color-dark);
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .slicer-title {
            font-size: 20px;
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 10px;
            text-shadow: 2px 2px 0 var(--shadow-color-dark);
        }

        .slicer-info {
            color: var(--text-color);
            margin-bottom: 20px;
            font-size: 10px;
        }

        .slicer-buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .slicer-btn {
            padding: 15px 25px;
            border: 2px solid var(--shadow-color-dark);
            box-shadow: 4px 4px 0 var(--shadow-color-dark);
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slicer-btn:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }

        .slicer-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 0 0 0 var(--shadow-color-dark);
        }

        .slicer-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed !important;
            background: var(--shadow-color-dark) !important;
            color: var(--bg-color) !important;
            transform: none !important;
        }

        .slicer-btn:disabled:hover {
            transform: none !important;
            background: var(--shadow-color-dark) !important;
        }

        .slicer-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .slicer-cancel {
            padding: 10px 20px;
            background: var(--shadow-color-dark);
            color: var(--bg-color);
            border: 2px solid var(--shadow-color-dark);
            box-shadow: 4px 4px 0 var(--shadow-color-dark);
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
        }

        .slicer-cancel:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }

        /* Indicador de slice en pads */
        .slice-indicator {
            position: absolute;
            bottom: 6px;
            right: 6px;
            background: var(--shadow-color-dark);
            color: var(--bg-color);
            font-size: 8px;
            padding: 2px 4px;
            border: 2px solid var(--shadow-color-dark);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
            z-index: 6;
            display: none;
            font-weight: bold;
            transform: translate(25%, 25%);
            min-width: 20px;
            text-align: center;
        }

        /* Botón para eliminar sample individual */
        .delete-pad-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 18px;
            height: 18px;
            background: var(--shadow-color-dark);
            color: var(--bg-color);
            border: 2px solid var(--shadow-color-dark);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            z-index: 15;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            line-height: 1;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            transform: translate(25%, -25%);
        }

        .delete-pad-btn:hover {
            transform: translate(25%, -25%) scale(1.1);
            box-shadow: 4px 4px 0 var(--shadow-color-dark);
        }

        .delete-pad-btn:active {
            transform: translate(25%, -25%) scale(0.9);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }

        /* Mostrar botón X solo cuando el pad tiene sample y se hace hover */
        .pad.loaded:hover .delete-pad-btn {
            display: flex;
        }

        /* En móviles, mantener el posicionamiento concéntrico */
        @media (max-width: 768px) {
            .pad.loaded .delete-pad-btn {
                display: flex;
                opacity: 0.8;
                width: 16px;
                height: 16px;
                font-size: 10px;
                top: 5px;
                right: 5px;
            }
            
            .pad.loaded .delete-pad-btn:hover {
                opacity: 1;
            }
            
            /* Slice indicator en móvil */
            .slice-indicator {
                bottom: 5px;
                right: 5px;
                font-size: 7px;
                padding: 1px 3px;
            }
        }

        /* En pantallas muy pequeñas */
        @media (max-width: 480px) {
            .delete-pad-btn {
                width: 14px;
                height: 14px;
                font-size: 9px;
                top: 4px;
                right: 4px;
            }
            
            .slice-indicator {
                bottom: 4px;
                right: 4px;
                font-size: 6px;
                padding: 1px 2px;
            }
        }

        /* Indicador de drop */
        .drop-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--shadow-color-dark);
            color: var(--bg-color);
            padding: 8px 12px;
            border: 2px solid var(--shadow-color-dark);
            box-shadow: 4px 4px 0 var(--shadow-color-dark);
            font-size: 10px;
            font-weight: bold;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .pad.drag-over .drop-indicator {
            opacity: 1;
        }

        /* Indicador de move operation */
        .move-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--shadow-color-dark);
            color: var(--bg-color);
            padding: 8px 12px;
            border: 2px solid var(--shadow-color-dark);
            box-shadow: 4px 4px 0 var(--shadow-color-dark);
            font-size: 10px;
            font-weight: bold;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .pad.selected-for-move .move-indicator {
            opacity: 1;
        }

        .pad:hover {
            background: var(--shadow-color-light);
        }

        /* Colores para diferentes tipos de pads */
        .pad:nth-child(4n+1) { 
            border-color: var(--shadow-color-dark);
        }
        .pad:nth-child(4n+2) { 
            border-color: var(--shadow-color-dark);
        }
        .pad:nth-child(4n+3) { 
            border-color: var(--shadow-color-dark);
        }
        .pad:nth-child(4n+4) { 
            border-color: var(--shadow-color-dark);
        }

        .pad:active, .pad.playing {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }

        .pad.loaded { opacity: 1; }

        .pad.loading {
            opacity: 0.5;
            animation: pulse 1.5s steps(4) infinite;
        }

        .visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(15, 56, 15, 0.1) !important;
            pointer-events: none;
            z-index: 1;
            border-radius: 0;
            overflow: hidden;
        }

        /* Etiquetas para mostrar el banco y nombre del sample */
        .sample-indicator {
            position: absolute;
            top: 5px;
            left: 5px;
            background-color: var(--shadow-color-dark);
            color: var(--bg-color);
            font-size: 8px;
            padding: 2px 4px;
            border: 2px solid var(--shadow-color-dark);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
            z-index: 5;
            display: none;
        }

        .sample-name {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 8px;
            color: var(--text-color);
            max-width: calc(100% - 35px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            z-index: 5;
            display: none;
        }

        /* Keyboard Indicator */
        .keyboard-indicator {
            position: absolute;
            top: 5px;
            left: 5px;
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 8px;
            font-weight: bold;
            padding: 2px 4px;
            border: 2px solid var(--shadow-color-dark);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
            z-index: 7;
            display: none;
            transform: none;
        }

        .pad.loaded .keyboard-indicator {
            display: block;
        }

        /* Ajustes para móviles */
        @media (max-width: 768px) {
            .keyboard-indicator {
                top: 4px;
                left: 4px;
                font-size: 7px;
                padding: 1px 3px;
            }
        }

        @media (max-width: 480px) {
            .keyboard-indicator {
                top: 3px;
                left: 3px;
                font-size: 6px;
                padding: 1px 2px;
            }
        }

        /* Efectos de brillo específicos por tipo de pad cuando están activos */
        .pad:nth-child(4n+1).playing { 
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }
        .pad:nth-child(4n+2).playing { 
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }
        .pad:nth-child(4n+3).playing { 
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }
        .pad:nth-child(4n+4).playing { 
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }

        @keyframes pulse {
            0% { opacity: 0.3; }
            50% { opacity: 0.6; }
            100% { opacity: 0.3; }
        }

        /* Footer Styles */
        footer {
            margin-top: 30px;
            text-align: center;
            padding: 20px;
            border: 2px solid var(--shadow-color-dark);
            box-shadow: 4px 4px 0 var(--shadow-color-dark);
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 10px;
        }

        #status-message {
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            color: var(--text-color);
            min-height: 24px;
            font-size: 10px;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .title-container h1 { 
                font-size: 20px; 
                margin-bottom: 10px;
            }
            
            .section-title { 
                font-size: 10px; 
                margin: 12px 0 8px; 
            }
            
            .header-row { 
                gap: 8px;
                margin-bottom: 10px;
            }
            
            .header-button { 
                height: 40px; 
                font-size: 10px;
            }
            
            .empty-space { 
                height: 40px; 
            }
            
            .pad-grid { 
                gap: 8px; 
            }
            
            .tempo-btn {
                font-size: 14px;
            }
            
            .tempo-display,
            .bar-btn {
                font-size: 10px;
            }
            
            .bar-label {
                font-size: 8px;
            }
            
            footer {
                margin-top: 20px;
                padding: 10px;
                font-size: 8px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .title-container h1 { 
                font-size: 16px; 
                margin-bottom: 8px;
            }
            
            .section-title { 
                font-size: 8px; 
                margin: 8px 0 5px; 
            }
            
            .header-row { 
                gap: 5px;
                margin-bottom: 8px;
            }
            
            .header-button { 
                height: 36px; 
                font-size: 8px;
                padding: 0 2px;
            }
            
            .empty-space { 
                height: 36px; 
            }
            
            .pad-grid { 
                gap: 5px; 
            }
            
            .tempo-btn {
                font-size: 12px;
            }
            
            .tempo-display,
            .bar-btn {
                font-size: 8px;
            }
            
            .bar-label {
                font-size: 6px;
            }
            
            footer {
                margin-top: 15px;
                padding: 8px;
                font-size: 6px;
            }
            
            #status-message {
                font-size: 8px;
                margin-top: 10px;
                min-height: 15px;
            }
        }
        
        /* Ajustes específicos para teléfonos pequeños */
        @media (max-width: 360px) {
            .header-button {
                font-size: 6px;
                height: 32px;
                padding: 0;
            }
            
            .tempo-controls {
                gap: 3px;
            }
            
            .pad-grid {
                gap: 4px;
            }
            
            .slicer-panel {
                width: 95%;
                padding: 20px;
            }
            
            .slicer-buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .slicer-btn {
                padding: 12px 20px;
                font-size: 10px;
            }
        }

        /* Estilos para el botón de slicer móvil */
        .btn-slicer {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-weight: normal;
            transition: all 0.2s ease;
        }

        .btn-slicer:hover {
            background-color: var(--shadow-color-light);
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color-dark);
        }
        
        .btn-slicer:active {
            transform: translate(4px, 4px);
            box-shadow: 0 0 0 var(--shadow-color-dark);
        }
        
        .btn-slicer:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: var(--shadow-color-dark) !important;
            color: var(--bg-color) !important;
            transform: none !important;
        }
        
        /* Responsive para el botón slicer */
        @media (max-width: 768px) {
            .btn-slicer {
                font-size: 10px;
                padding: 0 5px;
            }
        }
        
        @media (max-width: 480px) {
            .btn-slicer {
                font-size: 8px;
                padding: 0 2px;
            }
        }
        
        /* NUEVO: Estilos para indicador de swipe */
        .swipe-indicator {
            background: linear-gradient(45deg, var(--accent-color), var(--accent-color-light));
            color: var(--bg-color);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            text-align: center;
            margin: 10px auto;
            max-width: 400px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            animation: swipePulse 2s ease-in-out infinite;
        }
        
        @keyframes swipePulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }
        
        /* Responsive para indicador de swipe */
        @media (max-width: 768px) {
            .swipe-indicator {
                font-size: 0.8em;
                padding: 6px 12px;
                max-width: 350px;
            }
        }
        
        @media (max-width: 480px) {
            .swipe-indicator {
                font-size: 0.7em;
                padding: 5px 10px;
                max-width: 300px;
            }
        }
        
        /* Estilos para botones activos del secuenciador */
        .btn-record.active, .btn-play.active {
            background-color: var(--shadow-color-dark);
            color: var(--bg-color) !important;
            font-weight: bold;
        }
        
        /* Hover unificado para todos los botones del secuenciador */
        .sequencer-row .header-button:hover:not(.active) {
            background-color: var(--shadow-color-light);
        }
    </style>
</head>
<body>
    <div class="title-container">
        <h1>Embrio Player v3.0</h1>
    </div>

    <div class="header-row">
        <button id="start-audio" class="header-button"><i class="fas fa-power-off"></i> Start</button>
        <button id="help-button" class="header-button help-button">?</button>
        <div id="help-modal" class="help-modal">
            <div class="help-content">
                <h3>Controls</h3>
                <ul>
                    <li>Double-click: Open sample slicer</li>
                    <li>Long press + tap: Move sample to another pad</li>
                    <li>Keyboard mapping: 1234/QWER/ASDF/ZXCV → Pads 1-16</li>
                    <li>Input methods: 🖱️ Mouse/Touch • ⌨️ Keyboard • 🎹 MIDI</li>
                </ul>
                <button class="close-help">×</button>
            </div>
        </div>
        <div class="empty-space"></div>
        <div class="empty-space"></div>
    </div>
        
        <!-- NEW: Input Status Indicator -->
        <div id="input-status" class="input-status">
            Active methods: 🖱️ Mouse/Touch • ⌨️ Teclado • 🎹 MIDI (disconnected)
        </div>
        
        <!-- NEW: Swipe Gesture Indicator -->
        <div id="swipe-indicator" class="swipe-indicator" style="display: none;">
            <span>👆 Swipe activo - ←→ Cambiar Bank • ↑↓ Ajustar BPM</span>
        </div>
        
        <div class="section-title">Sequencer Section</div>
        
        <div class="header-row sequencer-row">
            <button id="record-sequence" class="header-button btn-record">REC</button>
            <button id="play-sequence" class="header-button btn-play">PLAY</button>
            <button id="stop-sequence" class="header-button">STOP</button>
            <button id="clear-sequence" class="header-button">CLEAR</button>
        </div>
        
        <div class="header-row tempo-controls">
            <button id="tempo-up" class="header-button tempo-btn bpm-button">+</button>
            <div id="tempo-display" class="header-button tempo-display">120 BPM</div>
            <button id="tempo-down" class="header-button tempo-btn bpm-button">-</button>
            <div class="header-button bar-label">bar / beat</div>
            <div id="current-bar" class="header-button bar-btn">1</div>
            <div id="current-beat" class="header-button bar-btn">1</div>
        </div>
        
        <div class="section-title">Bank Selection</div>
        <div class="header-row bank-selector-row">
            <button id="bank-a" class="header-button bank-btn bank-active">Bank A</button>
            <button id="bank-b" class="header-button bank-btn">Bank B</button>
            <button id="bank-c" class="header-button bank-btn">Bank C</button>
            <button id="bank-d" class="header-button bank-btn">Bank D</button>
        </div>
        
        <div class="header-row">
            <button id="load-samples" class="header-button btn-load">Load Samples</button>
            <button id="clear-bank" class="header-button">Clear Bank</button>
            <button id="mobile-slicer" class="header-button btn-slicer">🔪 Slicer</button>
            <div class="empty-space"></div>
        </div>
    </div>

    <div id="status-message">Please start audio to begin.</div>

    <main>
        <div id="pad-grid" class="pad-grid">
            <!-- Los pads se generan dinámicamente mediante JavaScript -->
        </div>
    </main>

    <!-- Modal del Sample Slicer -->
    <div id="slicer-modal" class="slicer-modal">
        <div class="slicer-panel">
            <div class="slicer-title">🔪 Sample Slicer</div>
            <div id="slicer-info" class="slicer-info">
                Slice "nombre-sample" en partes iguales
            </div>
            <div class="slicer-buttons" id="slicer-buttons">
                <button class="slicer-btn" onclick="embryoPlayer.applySlicer(4)">4 Slices</button>
                <button class="slicer-btn" onclick="embryoPlayer.applySlicer(8)">8 Slices</button>
                <button class="slicer-btn" onclick="embryoPlayer.applySlicer(16)">16 Slices</button>
            </div>
            <div class="slicer-actions">
                <button class="slicer-cancel" onclick="embryoPlayer.closeSlicerModal()">Cancelar</button>
            </div>
        </div>
    </div>

    <footer>
        <p>Embrio Player v3.0 - Con BPM long press, teclado completo, sistema híbrido de entrada y funcionalidades mejoradas</p>
    </footer>

    <script>
        /**
         * Embrio Player v3.0
         * Un sampler y secuenciador web avanzado con múltiples funcionalidades de audio.
         * 
         * @version 3.0
         * @author [Tu nombre]
         * @license MIT
         */
        
        /**
         * EMBRIO PLAYER v3.0 - ENHANCED VERSION
         * Reproductor de samples con secuenciador y funcionalidades avanzadas
         * 
         * NUEVAS CARACTERÍSTICAS v3.0:
         * - Long Press para BPM (cambios rápidos cada 150ms)
         * - Sistema de entrada múltiple mejorado (Mouse + Touch + Teclado + MIDI)
         * - Mapeo de teclado completo (QWER/ASDF/ZXCV/1234)
         * - Indicadores de método de entrada activo
         * - Feedback visual mejorado para todas las interacciones
         * - Sistema unificado de control de pads
         */
        
        // CONSTANTS & CONFIGURATION
        const GITHUB_REPO_URL = 'https://raw.githubusercontent.com/sebasdv/sampleplayer/main/samples/';
        const FFT_SIZE = 256;
        const BEATS_PER_BAR = 4;
        const MIN_BPM = 60;
        const MAX_BPM = 200;
        const PRE_COUNT_BARS = 1;
        const BAR_COUNT = 4;
        const LONG_PRESS_DURATION = 800; // Long press para move samples (reducido de 1200ms)
        const BPM_LONG_PRESS_DELAY = 200; // Delay para iniciar cambios rápidos de BPM (reducido de 300ms)
        const BPM_RAPID_INTERVAL = 200; // Intervalo para cambios rápidos de BPM (aumentado de 150ms para mejor control)

        // NUEVO: Constantes para feedback táctil y gestos
        const SWIPE_THRESHOLD = 50; // Distancia mínima para detectar swipe
        const SWIPE_TIMEOUT = 300; // Tiempo máximo para completar swipe
        const TACTILE_FEEDBACK_ENABLED = true; // Habilitar/deshabilitar feedback táctil

        // Lista de archivos de audio predeterminados
        const audioFiles = [
            '01-11Stringsjura78bpm.WAV', '02-Harpjura78bpm.WAV', '03-CHCleanVinyl01.WAV', '04-OHCleanVinyl08.WAV',
            '05-BDDegradedVinyl11.WAV', '06-SDTubeVinyl01.WAV', '07-CHCleanVinyl02.WAV', '08-OHCleanVinyl09.WAV',
            '09-BDDegradedVinyl13.WAV', '10-SDTubeVinyl02.WAV', '11-CHCleanVinyl03.WAV', '12-OHCleanVinyl10.WAV',
            '13-BDDegradedVinyl14.WAV', '14-SDTubeVinyl03.WAV', '15-CHCleanVinyl04.WAV', '16-OHCleanVinyl11.WAV'
        ];

        // PAD CONTROLLER CLASS - Sistema Unificado de Control
        class PadController {
            constructor(embryoPlayer) {
                this.embryoPlayer = embryoPlayer;
                this.pads = new Map();
                this.midiAvailable = false;
                
                // NEW: Mapeo de teclas a pads (personalizable)
                this.keyToPad = {
                    // Fila superior: 1234
                    '1': 1, '2': 2, '3': 3, '4': 4,
                    // Fila media superior: QWER
                    'q': 5, 'w': 6, 'e': 7, 'r': 8,
                    // Fila media inferior: ASDF
                    'a': 9, 's': 10, 'd': 11, 'f': 12,
                    // Fila inferior: ZXCV
                    'z': 13, 'x': 14, 'c': 15, 'v': 16
                };
                
                this.pressedKeys = new Set();
                this.init();
            }
            
            init() {
                this.setupKeyboardControl();
                this.updateInputStatus();
            }
            
            // Método unificado para activar cualquier pad
            triggerPad(padNumber, velocity, source) {
                velocity = velocity || 127;
                source = source || 'unknown';
                console.log('Pad ' + padNumber + ' activado desde ' + source + ' - Velocity: ' + velocity);
                
                // Reproducir sample
                this.embryoPlayer.playPad(padNumber);
                
                // Feedback visual unificado
                this.showPadFeedback(padNumber);
            }
            
            // Feedback visual para pads
            showPadFeedback(padNumber) {
                const padElement = document.querySelector('.pad[data-number="' + padNumber + '"]');
                if (padElement) {
                    padElement.classList.add('pad-active');
                    setTimeout(function() {
                        padElement.classList.remove('pad-active');
                    }, 150);
                }
            }
            
            // Configurar control por teclado
            setupKeyboardControl() {
                const self = this;
                
                document.addEventListener('keydown', function(e) {
                    const key = e.key.toLowerCase();
                    
                    // Evitar repetición si se mantiene presionada
                    if (self.pressedKeys.has(key)) return;
                    
                    // Solo procesar si no es un input de texto
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    self.pressedKeys.add(key);
                    
                    if (self.keyToPad[key]) {
                        e.preventDefault();
                        self.triggerPad(self.keyToPad[key], 127, 'keyboard');
                    }
                });
                
                document.addEventListener('keyup', function(e) {
                    const key = e.key.toLowerCase();
                    self.pressedKeys.delete(key);
                });
                
                // Limpiar teclas presionadas cuando la ventana pierde foco
                window.addEventListener('blur', function() {
                    self.pressedKeys.clear();
                });
            }
            
            // Configurar conexión MIDI
            setMIDIAvailable(available) {
                this.midiAvailable = available;
                this.updateInputStatus();
            }
            
            // Actualizar indicador de métodos de entrada
            updateInputStatus() {
                const statusDiv = document.getElementById('input-status');
                const methods = [];
                
                methods.push('🖱️ Mouse/Touch');
                methods.push('⌨️ Teclado');
                
                if (this.midiAvailable) {
                    methods.push('🎹 MIDI (conectado)');
                } else {
                    methods.push('🎹 MIDI (desconectado)');
                }
                
                statusDiv.innerHTML = 'Active methods: ' + methods.join(' • ');
            }
            
            // Obtener tecla para un pad específico
            getKeyForPad(padNumber) {
                for (const key in this.keyToPad) {
                    if (this.keyToPad[key] === padNumber) {
                        return key.toUpperCase();
                    }
                }
                return '';
            }
        }

        /**
         * Controlador de BPM
         * @class BPMController
         * @description Maneja el control de tempo y cambios de BPM
         * 
         * @property {EmbrioPlayer} embryoPlayer - Instancia del reproductor principal
         * @property {number} longPressTimer - Timer para long press
         * @property {number} rapidTimer - Timer para cambios rápidos
         * @property {boolean} isLongPressing - Estado de long press
         * 
         * @example
         * const bpmController = new BPMController(embryoPlayer);
         * bpmController.changeBPM(1); // Aumentar BPM
         */
        class BPMController {
            constructor(embryoPlayer) {
                this.embryoPlayer = embryoPlayer;
                this.longPressTimer = null;
                this.rapidTimer = null;
                this.isLongPressing = false;
                this.init();
            }
            
            init() {
                this.setupBPMButtons();
            }
            
            // Configurar botones de BPM con long press
            setupBPMButtons() {
                const bpmUpBtn = document.getElementById('tempo-up');
                const bpmDownBtn = document.getElementById('tempo-down');
                
                // Botón de aumentar BPM
                this.setupBPMButton(bpmUpBtn, 1);
                
                // Botón de disminuir BPM
                this.setupBPMButton(bpmDownBtn, -1);
            }
            
            // Configurar un botón de BPM individual
            setupBPMButton(button, direction) {
                const self = this;
                
                // Mouse events
                button.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    self.startBPMLongPress(direction, button);
                });
                
                button.addEventListener('mouseup', function(e) {
                    e.preventDefault();
                    self.stopBPMLongPress(button);
                });
                
                button.addEventListener('mouseleave', function(e) {
                    self.stopBPMLongPress(button);
                });
                
                // Touch events
                button.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    self.startBPMLongPress(direction, button);
                });
                
                button.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    self.stopBPMLongPress(button);
                });
                
                button.addEventListener('touchcancel', function(e) {
                    e.preventDefault();
                    self.stopBPMLongPress(button);
                });
            }
            
            // Iniciar long press para BPM
            startBPMLongPress(direction, button) {
                const self = this;
                
                // Cambio inmediato (clic simple)
                this.changeBPM(direction);
                
                // Iniciar long press después del delay
                this.longPressTimer = setTimeout(function() {
                    self.isLongPressing = true;
                    button.classList.add('long-pressing');
                    
                    // Cambios rápidos cada intervalo especificado
                    self.rapidTimer = setInterval(function() {
                        if (self.isLongPressing) {
                            self.changeBPM(direction);
                        } else {
                            clearInterval(self.rapidTimer);
                            self.rapidTimer = null;
                        }
                    }, BPM_RAPID_INTERVAL);
                }, BPM_LONG_PRESS_DELAY);
            }
            
            // Detener long press para BPM
            stopBPMLongPress(button) {
                if (this.longPressTimer) {
                    clearTimeout(this.longPressTimer);
                    this.longPressTimer = null;
                }
                
                if (this.rapidTimer) {
                    clearInterval(this.rapidTimer);
                    this.rapidTimer = null;
                }
                
                this.isLongPressing = false;
                button.classList.remove('long-pressing');
            }
            
            // Cambiar BPM
            changeBPM(direction) {
                this.embryoPlayer.changeTempo(direction);
            }
        }

        /**
         * Clase principal del reproductor
         * @class EmbrioPlayer
         * @description Maneja la lógica principal del reproductor, incluyendo audio, secuenciador y UI
         * 
         * @property {AudioContext} audioContext - Contexto de audio Web Audio API
         * @property {Object} samples - Mapa de samples cargados
         * @property {Object} activeSources - Fuentes de audio activas
         * @property {Object} visualizers - Visualizadores de audio
         * @property {Set} touchedPads - Pads tocados actualmente
         * @property {boolean} isAudioInitialized - Estado de inicialización del audio
         * @property {boolean} isRecording - Estado de grabación
         * @property {boolean} isPlaying - Estado de reproducción
         * @property {number} bpm - Tempo actual
         * @property {number} currentBar - Compás actual
         * @property {number} currentBeat - Pulso actual
         * @property {Array} sequence - Secuencia grabada
         * 
         * @example
         * const player = new EmbrioPlayer();
         * player.initAudio();
         */
        class EmbrioPlayer {
            constructor() {
                // Audio
                this.audioContext = null;
                this.samples = {};
                this.activeSources = {};
                this.visualizers = {};
                
                // Estado de la UI
                this.touchedPads = new Set();
                this.isAudioInitialized = false;
                
                // Secuenciador
                this.isRecording = false;
                this.isPlaying = false;
                this.bpm = 120;
                this.currentBar = 0;
                this.currentBeat = 1;
                this.sequence = Array(BAR_COUNT).fill().map(function() { return []; });
                this.sequenceStartTime = 0;
                this.metronomeInterval = null;
                this.beatInterval = null;
                this.barAdvancementInterval = null;
                
                // MIDI
                this.midiAccess = null;
                
                // Bancos de sonidos
                this.currentBank = 'A';
                this.bankSamples = {
                    'A': {}, 'B': {}, 'C': {}, 'D': {}
                };

                // Nombres de los samples
                this.sampleNames = {
                    'A': {}, 'B': {}, 'C': {}, 'D': {}
                };

                // Sample Slicer
                this.slicerSourcePad = null;
                this.slicerSourceBuffer = null;
                this.slices = {};

                // Move Samples
                this.moveState = {
                    isActive: false,
                    sourcePad: null,
                    longPressTimer: null,
                    isPressing: false
                };
                
                // NEW: Controladores especializados
                this.padController = new PadController(this);
                this.bpmController = new BPMController(this);
                
                // Inicializar
                this.initEventListeners();
                this.loadSampleInfoFromStorage();
                
                // NUEVO: Inicializar detección de swipe y feedback táctil
                this.initSwipeDetection();
            }
            
            // INICIALIZACIÓN Y CONFIGURACIÓN
            loadSampleInfoFromStorage() {
                try {
                    const savedInfo = localStorage.getItem('embryoPlayerSamples');
                    if (savedInfo) {
                        const info = JSON.parse(savedInfo);
                        if (info.sampleNames) {
                            this.sampleNames = info.sampleNames;
                        }
                    }
                } catch (e) {
                    console.error('Error cargando información guardada:', e);
                }
            }
            
            saveSampleInfo() {
                try {
                    const info = {
                        sampleNames: this.sampleNames
                    };
                    localStorage.setItem('embryoPlayerSamples', JSON.stringify(info));
                } catch (e) {
                    console.error('Error guardando información:', e);
                }
            }
            
            initEventListeners() {
                const self = this;
                
                // Botones principales
                document.getElementById('start-audio').addEventListener('click', function() { self.initAudio(); });
                document.getElementById('help-button').addEventListener('click', function() {
                    document.getElementById('help-modal').style.display = 'block';
                });
                document.querySelector('.close-help').addEventListener('click', function() {
                    document.getElementById('help-modal').style.display = 'none';
                });
                document.getElementById('record-sequence').addEventListener('click', function() { self.toggleRecording(); });
                document.getElementById('play-sequence').addEventListener('click', function() { self.playSequence(); });
                document.getElementById('stop-sequence').addEventListener('click', function() { self.stopSequence(); });
                document.getElementById('clear-sequence').addEventListener('click', function() { self.clearSequence(); });
                
                // Botones de selección de banco
                document.getElementById('bank-a').addEventListener('click', function() { self.selectBank('A'); });
                document.getElementById('bank-b').addEventListener('click', function() { self.selectBank('B'); });
                document.getElementById('bank-c').addEventListener('click', function() { self.selectBank('C'); });
                document.getElementById('bank-d').addEventListener('click', function() { self.selectBank('D'); });
                
                // Botones para carga por lotes
                document.getElementById('load-samples').addEventListener('click', function() { self.loadMultipleSamples(); });
                document.getElementById('clear-bank').addEventListener('click', function() { self.clearCurrentBank(); });
                
                // NUEVO: Botón táctil para slicer
                document.getElementById('mobile-slicer').addEventListener('click', function() { 
                    self.showPadSelectorForSlicer(); 
                });
                
                // Responsive
                window.addEventListener('resize', function() { self.resizeCanvases(); });
            }
            
            /**
             * Inicializa el audio
             * @method initAudio
             * @description Crea el contexto de audio y prepara el reproductor
             * @throws {Error} Si no se puede crear el contexto de audio
             * @returns {Promise} Promesa que se resuelve cuando el audio está listo
             */
            initAudio() {
                const self = this;
                
                if (this.audioContext) {
                    this.updateStatus('El audio ya está iniciado.');
                    return;
                }
                
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContextClass();
                    this.isAudioInitialized = true;
                    
                    // Actualizar UI
                    document.getElementById('start-audio').disabled = true;
                    // NUEVO: Feedback táctil al iniciar audio
                    this.triggerTactileFeedback('strong');
                    this.playTactileSound(1200, 0.15);
                    
                    this.updateStatus('Audio iniciado. Cargando samples...');
                    
                    // Inicializar componentes
                    this.createPadGrid();
                    this.initMIDI();
                    this.loadAllSamples().then(function() {
                        self.updateStatus('All samples loaded. Ready to play.');
                    });
                    
                } catch (error) {
                    console.error('Error al iniciar el audio:', error);
                    this.updateStatus('Error starting audio: ' + error.message + '. Please reload the page.');
                }
            }
            
            // SISTEMA DE PADS MEJORADO
            createPadGrid() {
                const grid = document.getElementById('pad-grid');
                grid.innerHTML = '';
                
                for (let i = 1; i <= 16; i++) {
                    const pad = document.createElement('div');
                    pad.className = 'pad';
                    pad.dataset.number = i;
                    
                    // Crear canvas para visualizador
                    const visualizer = document.createElement('canvas');
                    visualizer.className = 'visualizer';
                    pad.appendChild(visualizer);
                    
                    // Crear indicador de drop
                    const dropIndicator = document.createElement('div');
                    dropIndicator.className = 'drop-indicator';
                    dropIndicator.textContent = 'Soltar aquí';
                    pad.appendChild(dropIndicator);
                    
                    // Crear indicador de banco
                    const sampleIndicator = document.createElement('div');
                    sampleIndicator.className = 'sample-indicator';
                    sampleIndicator.style.display = 'none';
                    pad.appendChild(sampleIndicator);
                    
                    // Crear etiqueta para nombre de sample
                    const nameLabel = document.createElement('div');
                    nameLabel.className = 'sample-name';
                    nameLabel.style.display = 'none';
                    pad.appendChild(nameLabel);
                    
                    // Crear indicador de slice
                    const sliceIndicator = document.createElement('div');
                    sliceIndicator.className = 'slice-indicator';
                    sliceIndicator.style.display = 'none';
                    pad.appendChild(sliceIndicator);
                    
                    // NEW: Crear indicador de teclado
                    const keyboardIndicator = document.createElement('div');
                    keyboardIndicator.className = 'keyboard-indicator';
                    keyboardIndicator.textContent = this.padController.getKeyForPad(i);
                    keyboardIndicator.style.display = 'none';
                    pad.appendChild(keyboardIndicator);
                    
                    // Crear botón para eliminar sample
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-pad-btn';
                    deleteBtn.innerHTML = '×';
                    deleteBtn.title = 'Eliminar sample';
                    
                    // Event listeners para eliminar
                    const self = this;
                    deleteBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        self.deletePadSample(i);
                    });
                    
                    deleteBtn.addEventListener('mousedown', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                    });
                    
                    deleteBtn.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                    });
                    
                    pad.appendChild(deleteBtn);
                    
                    // NUEVOS EVENT LISTENERS MEJORADOS
                    this.setupPadEventListeners(pad, i);
                    this.setupDragAndDrop(pad, i);
                    
                    grid.appendChild(pad);
                }
                
                this.resizeCanvases();
            }
            
            // Configurar event listeners para un pad
            setupPadEventListeners(pad, padNumber) {
                const self = this;
                
                // Mouse events
                pad.addEventListener('mousedown', function(e) {
                    if (e.target.classList.contains('delete-pad-btn')) return;
                    e.preventDefault();
                    self.startLongPress(padNumber);
                });
                
                pad.addEventListener('mouseup', function(e) {
                    e.preventDefault();
                    if (self.moveState.isActive) {
                        self.executeMoveOperation(padNumber);
                        return;
                    }
                    self.cancelLongPress();
                    if (self.moveState.isPressing) {
                        if (e.detail === 2) return; // Evitar doble clic
                        self.padController.triggerPad(padNumber, 127, 'mouse');
                    }
                });
                
                pad.addEventListener('mouseleave', function() {
                    self.cancelLongPress();
                });
                
                // Touch events
                pad.addEventListener('touchstart', function(e) {
                    if (e.target.classList.contains('delete-pad-btn')) return;
                    e.preventDefault();
                    self.startLongPress(padNumber);
                    
                    // Detección de doble tap
                    const now = Date.now();
                    const timeSinceLastTap = now - (self.lastTapTime || 0);
                    const lastTappedPad = self.lastTappedPad;
                    
                    self.lastTapTime = now;
                    self.lastTappedPad = padNumber;
                    
                    if (timeSinceLastTap < 300 && lastTappedPad === padNumber) {
                        self.cancelLongPress();
                        self.openSlicerModal(padNumber);
                        return;
                    }
                });
                
                pad.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    if (self.moveState.isActive) {
                        self.executeMoveOperation(padNumber);
                        return;
                    }
                    self.cancelLongPress();
                    if (self.moveState.isPressing) {
                        setTimeout(function() {
                            const currentTime = Date.now();
                            if (currentTime - self.lastTapTime >= 250) {
                                self.padController.triggerPad(padNumber, 127, 'touch');
                                self.touchedPads.add(padNumber);
                            }
                        }, 250);
                    }
                    self.touchedPads.delete(padNumber);
                });
                
                pad.addEventListener('touchcancel', function() {
                    self.cancelLongPress();
                    self.touchedPads.delete(padNumber);
                });
                
                // Doble clic para slicer
                pad.addEventListener('dblclick', function(e) {
                    e.preventDefault();
                    self.cancelLongPress();
                    self.openSlicerModal(padNumber);
                });
            }
            
            // REPRODUCCIÓN Y CONTROL DE AUDIO
            playPad(padNumber) {
                if (!this.validatePlayback(padNumber)) return;
                
                // NUEVO: Feedback táctil al tocar pad
                this.triggerTactileFeedback('medium');
                this.playTactileSound(400, 0.06);
                
                this.stopPadIfPlaying(padNumber);
                
                const source = this.createAudioSource(padNumber);
                const analyser = this.createAnalyser();
                
                source.connect(analyser);
                analyser.connect(this.audioContext.destination);
                
                source.start(0);
                this.activeSources[padNumber] = source;
                
                this.updatePadUI(padNumber, source);
                
                const canvas = document.querySelector('.pad[data-number="' + padNumber + '"] .visualizer');
                if (canvas) {
                    this.visualize(padNumber, analyser, canvas);
                }
                
                if (this.isRecording) {
                    this.recordPadEvent(padNumber);
                }
                
                this.updateStatus('Playing Pad ' + padNumber + ' (Bank ' + this.currentBank + ')');
            }
            
            validatePlayback(padNumber) {
                if (!this.audioContext) {
                    this.updateStatus('Por favor, inicia el audio antes de reproducir samples.');
                    return false;
                }
                
                if (!this.samples[padNumber]) {
                    this.updateStatus('No hay audio asignado al Pad ' + padNumber + ' en el Banco ' + this.currentBank);
                    return false;
                }
                
                return true;
            }
            
            stopPadIfPlaying(padNumber) {
                if (this.activeSources[padNumber]) {
                    try {
                        this.activeSources[padNumber].stop();
                        this.activeSources[padNumber].disconnect();
                    } catch (e) {
                        console.warn('Error al detener fuente de audio:', e);
                    }
                }
            }
            
            createAudioSource(padNumber) {
                const source = this.audioContext.createBufferSource();
                source.buffer = this.samples[padNumber];
                return source;
            }
            
            createAnalyser() {
                const analyser = this.audioContext.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                return analyser;
            }
            
            updatePadUI(padNumber, source) {
                const self = this;
                const pad = document.querySelector('.pad[data-number="' + padNumber + '"]');
                if (!pad) return;
                
                pad.classList.add('playing');
                
                source.onended = function() {
                    pad.classList.remove('playing');
                    delete self.activeSources[padNumber];
                    
                    if (self.visualizers[padNumber]) {
                        cancelAnimationFrame(self.visualizers[padNumber]);
                        delete self.visualizers[padNumber];
                    }
                };
            }
            
            // MIDI INTEGRATION
            initMIDI() {
                const self = this;
                
                if (navigator.requestMIDIAccess) {
                    navigator.requestMIDIAccess()
                        .then(function(midiAccess) { self.onMIDISuccess(midiAccess); })
                        .catch(function(error) { self.onMIDIFailure(error); });
                } else {
                    this.updateStatus('Web MIDI API no soportada en este navegador.');
                }
            }
            
            onMIDISuccess(midiAccess) {
                const self = this;
                this.midiAccess = midiAccess;
                this.padController.setMIDIAvailable(true);
                
                const inputs = midiAccess.inputs.values();
                
                for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
                    input.value.onmidimessage = function(msg) { self.onMIDIMessage(msg); };
                }
                
                this.updateStatus('MIDI conectado (OMNI - todos los canales). Controlador MIDI listo.');
            }
            
            onMIDIFailure(error) {
                console.error('Error al acceder al MIDI:', error);
                this.padController.setMIDIAvailable(false);
                this.updateStatus('Error al conectar MIDI. Puedes seguir usando el mouse, touch o teclado.');
            }
            
            onMIDIMessage(message) {
                const data = message.data;
                const status = data[0];
                const note = data[1]; 
                const velocity = data[2];
                
                // Detectar Note On en cualquier canal MIDI (144-159 = 0x90-0x9F)
                if ((status >= 144 && status <= 159) && velocity > 0) {
                    const padNumber = note % 16 + 1;
                    
                    // MIDI utiliza el sistema unificado
                    this.padController.triggerPad(padNumber, velocity, 'MIDI');
                    
                    console.log('MIDI: Canal ' + ((status & 0x0F) + 1) + ', Nota ' + note + ', Velocity ' + velocity + ' → Pad ' + padNumber);
                }
            }
            
            // FUNCIONALIDAD DE MOVER SAMPLES (MEJORADA)
            startLongPress(padNumber) {
                this.cancelLongPress();
                
                if (!this.samples[padNumber]) {
                    return;
                }
                
                this.moveState.isPressing = true;
                
                const self = this;
                this.moveState.longPressTimer = setTimeout(function() {
                    if (self.moveState.isPressing) {
                        self.activateMoveMode(padNumber);
                    }
                }, LONG_PRESS_DURATION);
            }
            
            cancelLongPress() {
                this.moveState.isPressing = false;
                
                if (this.moveState.longPressTimer) {
                    clearTimeout(this.moveState.longPressTimer);
                    this.moveState.longPressTimer = null;
                }
            }
            
            activateMoveMode(sourcePadNumber) {
                if (this.moveState.isActive) {
                    this.cancelMoveOperation();
                }
                
                this.moveState.isActive = true;
                this.moveState.sourcePad = sourcePadNumber;
                
                const sourcePad = document.querySelector('.pad[data-number="' + sourcePadNumber + '"]');
                if (sourcePad) {
                    sourcePad.classList.add('selected-for-move');
                    
                    let moveIndicator = sourcePad.querySelector('.move-indicator');
                    if (!moveIndicator) {
                        moveIndicator = document.createElement('div');
                        moveIndicator.className = 'move-indicator';
                        sourcePad.appendChild(moveIndicator);
                    }
                    moveIndicator.textContent = '🔄 Seleccionado';
                }
                
                const sampleName = this.sampleNames[this.currentBank][sourcePadNumber] || ('Sample ' + sourcePadNumber);
                this.updateStatus('🔄 "' + sampleName + '" seleccionado. Tap en otro pad para mover o mismo pad para cancelar.');
                
                if (navigator.vibrate) {
                    navigator.vibrate(100);
                }
            }
            
            executeMoveOperation(targetPadNumber) {
                const sourcePadNumber = this.moveState.sourcePad;
                
                if (!sourcePadNumber || sourcePadNumber === targetPadNumber) {
                    this.cancelMoveOperation();
                    return;
                }
                
                const sourceBuffer = this.bankSamples[this.currentBank][sourcePadNumber];
                const sourceName = this.sampleNames[this.currentBank][sourcePadNumber];
                
                if (!sourceBuffer) {
                    this.cancelMoveOperation();
                    this.updateStatus('❌ Error: No se encontró el sample origen');
                    return;
                }
                
                const targetHasSample = !!this.bankSamples[this.currentBank][targetPadNumber];
                if (targetHasSample) {
                    const targetName = this.sampleNames[this.currentBank][targetPadNumber] || ('Sample ' + targetPadNumber);
                    if (!confirm('¿Mover "' + sourceName + '" al Pad ' + targetPadNumber + '?\nEsto reemplazará "' + targetName + '"')) {
                        this.cancelMoveOperation();
                        return;
                    }
                }
                
                this.stopPadIfPlaying(sourcePadNumber);
                this.stopPadIfPlaying(targetPadNumber);
                
                // Mover el sample
                this.bankSamples[this.currentBank][targetPadNumber] = sourceBuffer;
                this.samples[targetPadNumber] = sourceBuffer;
                this.sampleNames[this.currentBank][targetPadNumber] = sourceName;
                
                // Eliminar del pad origen
                delete this.bankSamples[this.currentBank][sourcePadNumber];
                delete this.samples[sourcePadNumber];
                delete this.sampleNames[this.currentBank][sourcePadNumber];
                
                this.updatePadBankIndicators();
                
                const targetPad = document.querySelector('.pad[data-number="' + targetPadNumber + '"]');
                if (targetPad) {
                    this.showLoadedEffect(targetPad);
                }
                
                this.saveSampleInfo();
                this.cancelMoveOperation();
                
                this.updateStatus('✅ "' + sourceName + '" movido del Pad ' + sourcePadNumber + ' al Pad ' + targetPadNumber);
                
                if (navigator.vibrate) {
                    navigator.vibrate([50, 50, 50]);
                }
            }
            
            cancelMoveOperation() {
                if (this.moveState.sourcePad) {
                    const sourcePad = document.querySelector('.pad[data-number="' + this.moveState.sourcePad + '"]');
                    if (sourcePad) {
                        sourcePad.classList.remove('selected-for-move');
                        
                        const moveIndicator = sourcePad.querySelector('.move-indicator');
                        if (moveIndicator) {
                            moveIndicator.remove();
                        }
                    }
                }
                
                this.moveState.isActive = false;
                this.moveState.sourcePad = null;
                this.cancelLongPress();
                
                this.updateStatus('🔄 Operación de mover cancelada');
            }
            
            // TEMPO Y BPM (MEJORADO)
            changeTempo(change) {
                this.bpm = Math.max(MIN_BPM, Math.min(MAX_BPM, this.bpm + change));
                document.getElementById('tempo-display').textContent = this.bpm + ' BPM';
                
                // NUEVO: Feedback táctil al cambiar BPM
                this.triggerTactileFeedback('light');
                this.playTactileSound(500, 0.03);
                
                if (this.isRecording || this.isPlaying) {
                    this.restartTimers();
                }
            }
            
            restartTimers() {
                this.stopTimers();
                
                if (this.isRecording || this.isPlaying) {
                    if (this.isRecording) {
                        this.startMetronome();
                    }
                    this.startBarAdvancement();
                }
            }
            
            stopTimers() {
                if (this.metronomeInterval) {
                    clearInterval(this.metronomeInterval);
                    this.metronomeInterval = null;
                }
                
                if (this.beatInterval) {
                    clearInterval(this.beatInterval);
                    this.beatInterval = null;
                }
                
                if (this.barAdvancementInterval) {
                    clearInterval(this.barAdvancementInterval);
                    this.barAdvancementInterval = null;
                }
            }
            
            // SISTEMA DE BANCOS (EXISTENTE)
            selectBank(bank) {
                if (this.currentBank === bank) return;
                
                if (this.moveState.isActive) {
                    this.cancelMoveOperation();
                }
                
                this.currentBank = bank;
                
                document.querySelectorAll('.bank-btn').forEach(function(btn) {
                    btn.classList.remove('bank-active');
                });
                document.getElementById('bank-' + bank.toLowerCase()).classList.add('bank-active');
                
                this.samples = this.bankSamples[bank] || {};
                this.updatePadBankIndicators();
                
                // NUEVO: Feedback táctil al cambiar bank
                this.triggerTactileFeedback('light');
                this.playTactileSound(600, 0.04);
                
                this.updateStatus('Banco ' + bank + ' seleccionado.');
            }

            updatePadBankIndicators() {
                for (let i = 1; i <= 16; i++) {
                    const pad = document.querySelector('.pad[data-number="' + i + '"]');
                    if (!pad) continue;
                    
                    // Indicadores existentes
                    let nameLabel = pad.querySelector('.sample-name');
                    let sliceIndicator = pad.querySelector('.slice-indicator');
                    let deleteBtn = pad.querySelector('.delete-pad-btn');
                    let keyboardIndicator = pad.querySelector('.keyboard-indicator');
                    
                    // Crear indicadores si no existen
                    if (!nameLabel) {
                        nameLabel = document.createElement('div');
                        nameLabel.className = 'sample-name';
                        pad.appendChild(nameLabel);
                    }
                    
                    if (!sliceIndicator) {
                        sliceIndicator = document.createElement('div');
                        sliceIndicator.className = 'slice-indicator';
                        pad.appendChild(sliceIndicator);
                    }
                    
                    if (!keyboardIndicator) {
                        keyboardIndicator = document.createElement('div');
                        keyboardIndicator.className = 'keyboard-indicator';
                        keyboardIndicator.textContent = this.padController.getKeyForPad(i);
                        pad.appendChild(keyboardIndicator);
                    }
                    
                    if (!deleteBtn) {
                        deleteBtn = document.createElement('button');
                        deleteBtn.className = 'delete-pad-btn';
                        deleteBtn.innerHTML = '×';
                        deleteBtn.title = 'Eliminar sample';
                        
                        const self = this;
                        deleteBtn.addEventListener('click', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            self.deletePadSample(i);
                        });
                        
                        deleteBtn.addEventListener('mousedown', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                        });
                        
                        deleteBtn.addEventListener('touchstart', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                        });
                        
                        pad.appendChild(deleteBtn);
                    }
                    
                    // Verificar si hay sample en este pad
                    const hasSample = !!this.bankSamples[this.currentBank][i];
                    
                    if (hasSample) {
                        pad.classList.add('loaded');
                        
                        const name = this.sampleNames[this.currentBank][i] || ('Sample ' + i);
                        nameLabel.textContent = name;
                        nameLabel.style.display = 'block';
                        
                        deleteBtn.style.display = 'flex';
                        keyboardIndicator.style.display = 'block';
                        
                        if (name.indexOf('-') === -1) {
                            sliceIndicator.style.display = 'none';
                        }
                    } else {
                        pad.classList.remove('loaded');
                        nameLabel.style.display = 'none';
                        sliceIndicator.style.display = 'none';
                        deleteBtn.style.display = 'none';
                        keyboardIndicator.style.display = 'none';
                    }
                }
            }
            
            // CARGA DE SAMPLES (EXISTENTE)
            loadMultipleSamples() {
                if (!this.audioContext) {
                    this.updateStatus('Por favor, inicia el audio primero');
                    return;
                }
                
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'audio/*';
                input.multiple = true;
                
                const self = this;
                input.onchange = function(e) {
                    const files = Array.from(e.target.files);
                    if (files.length === 0) return;
                    
                    const filesToLoad = files.slice(0, 16);
                    
                    self.updateStatus('Cargando ' + filesToLoad.length + ' samples en el Banco ' + self.currentBank + '...');
                    
                    filesToLoad.forEach(function(file, index) {
                        const padNumber = index + 1;
                        if (padNumber > 16) return;
                        
                        if (self.validateAudioFile(file)) {
                            self.loadUserSample(padNumber, self.currentBank, file);
                        }
                    });
                };
                
                input.click();
            }

            clearCurrentBank() {
                const bank = this.currentBank;
                
                if (confirm('Are you sure you want to clear all samples from Bank ' + bank + '?')) {
                    this.bankSamples[bank] = {};
                    this.samples = {};
                    this.sampleNames[bank] = {};
                    
                    this.updatePadBankIndicators();
                    this.saveSampleInfo();
                    
                    this.updateStatus('All samples from Bank ' + bank + ' have been cleared.');
                }
            }
            
            deletePadSample(padNumber) {
                const bank = this.currentBank;
                const sampleName = this.sampleNames[bank][padNumber] || ('Pad ' + padNumber);
                
                this.stopPadIfPlaying(padNumber);
                
                delete this.bankSamples[bank][padNumber];
                delete this.samples[padNumber];
                delete this.sampleNames[bank][padNumber];
                
                const pad = document.querySelector('.pad[data-number="' + padNumber + '"]');
                if (pad) {
                    pad.classList.remove('loaded');
                    
                    const sampleIndicator = pad.querySelector('.sample-indicator');
                    const nameLabel = pad.querySelector('.sample-name');
                    const sliceIndicator = pad.querySelector('.slice-indicator');
                    const deleteBtn = pad.querySelector('.delete-pad-btn');
                    const keyboardIndicator = pad.querySelector('.keyboard-indicator');
                    
                    if (sampleIndicator) sampleIndicator.style.display = 'none';
                    if (nameLabel) nameLabel.style.display = 'none';
                    if (sliceIndicator) sliceIndicator.style.display = 'none';
                    if (deleteBtn) deleteBtn.style.display = 'none';
                    if (keyboardIndicator) keyboardIndicator.style.display = 'none';
                }
                
                this.saveSampleInfo();
                
                this.updateStatus('🗑️ "' + sampleName + '" eliminado del Pad ' + padNumber);
            }
            
            // FUNCIONES AUXILIARES Y UTILIDADES
            updateStatus(message) {
                document.getElementById('status-message').textContent = message;
            }
            
            showLoadedEffect(pad) {
                const originalBoxShadow = pad.style.boxShadow;
                pad.style.boxShadow = '0 0 30px rgba(255, 255, 255, 0.8)';
                
                setTimeout(function() {
                    pad.style.boxShadow = originalBoxShadow;
                }, 500);
            }
            
            // RESTO DE FUNCIONES EXISTENTES
            setupDragAndDrop(pad, padNumber) {
                const self = this;
                pad.addEventListener('dragenter', function(e) { self.handleDragEnter(e, padNumber); }, false);
                pad.addEventListener('dragover', function(e) { self.handleDragOver(e, padNumber); }, false);
                pad.addEventListener('dragleave', function(e) { self.handleDragLeave(e, padNumber); }, false);
                pad.addEventListener('drop', function(e) { self.handleDrop(e, padNumber); }, false);
            }
            
            handleDragEnter(e, padNumber) {
                e.preventDefault();
                e.stopPropagation();
                
                const pad = e.currentTarget;
                const files = Array.from(e.dataTransfer.files);
                
                if (files.length > 0) {
                    const self = this;
                    const validFiles = files.filter(function(file) { return self.validateAudioFile(file); });
                    
                    if (validFiles.length > 0) {
                        pad.classList.add('drag-over', 'drag-valid');
                        const indicator = pad.querySelector('.drop-indicator');
                        
                        if (files.length === 1) {
                            indicator.textContent = '📁 ' + files[0].name;
                        } else {
                            indicator.textContent = '📁 ' + validFiles.length + ' archivos';
                        }
                    } else {
                        pad.classList.add('drag-over', 'drag-invalid');
                        const indicator = pad.querySelector('.drop-indicator');
                        indicator.textContent = '❌ Formato no válido';
                    }
                }
            }
            
            handleDragOver(e, padNumber) {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'copy';
            }
            
            handleDragLeave(e, padNumber) {
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    const pad = e.currentTarget;
                    pad.classList.remove('drag-over', 'drag-valid', 'drag-invalid');
                    
                    const indicator = pad.querySelector('.drop-indicator');
                    indicator.textContent = 'Soltar aquí';
                }
            }
            
            handleDrop(e, padNumber) {
                e.preventDefault();
                e.stopPropagation();
                
                const pad = e.currentTarget;
                pad.classList.remove('drag-over', 'drag-valid', 'drag-invalid');
                
                const files = Array.from(e.dataTransfer.files);
                
                if (files.length > 0) {
                    if (!this.audioContext) {
                        this.updateStatus('Por favor, inicia el audio antes de cargar samples');
                        return;
                    }
                    
                    const self = this;
                    const validFiles = files.filter(function(file) { return self.validateAudioFile(file); });
                    
                    if (validFiles.length === 0) {
                        this.updateStatus('❌ No se encontraron archivos de audio válidos');
                        return;
                    }
                    
                    if (validFiles.length === 1) {
                        const file = validFiles[0];
                        this.updateStatus('📁 Cargando "' + file.name + '" en Pad ' + padNumber + '...');
                        this.loadUserSample(padNumber, this.currentBank, file);
                    } else {
                        this.loadMultipleFilesToPads(validFiles, padNumber);
                    }
                }
                
                const indicator = pad.querySelector('.drop-indicator');
                indicator.textContent = 'Soltar aquí';
            }
            
            loadMultipleFilesToPads(files, startPadNumber) {
                this.updateStatus('📁 Cargando ' + files.length + ' archivos desde Pad ' + startPadNumber + '...');
                
                const self = this;
                files.forEach(function(file, index) {
                    const targetPad = startPadNumber + index;
                    if (targetPad <= 16) {
                        setTimeout(function() {
                            self.loadUserSample(targetPad, self.currentBank, file);
                        }, index * 100);
                    }
                });
                
                const totalLoaded = Math.min(files.length, 16 - startPadNumber + 1);
                this.updateStatus('📁 Cargando ' + totalLoaded + ' samples desde Pad ' + startPadNumber + '...');
            }
            
            validateAudioFile(file) {
                if (!file) return false;
                
                const validTypes = [
                    'audio/wav', 'audio/x-wav', 'audio/mp3', 'audio/mpeg', 
                    'audio/ogg', 'audio/aac', 'audio/m4a', 'audio/flac'
                ];
                
                const fileName = file.name.toLowerCase();
                const extension = fileName.split('.').pop();
                const validExtensions = ['wav', 'mp3', 'ogg', 'aac', 'm4a', 'flac'];
                
                const isValidType = validTypes.includes(file.type) || 
                                   validExtensions.includes(extension);
                
                if (!isValidType) {
                    return false;
                }
                
                if (file.size > 50 * 1024 * 1024) { // 50MB
                    return false;
                }
                
                return true;
            }
            
            loadUserSample(padNumber, bank, file) {
                try {
                    // Validaciones mejoradas
                    if (!this.audioContext) {
                        throw new Error('Audio no inicializado. Por favor, inicia el audio primero.');
                    }
                    
                    if (!file || file.size === 0) {
                        throw new Error('Archivo inválido o vacío.');
                    }
                    
                    if (file.size > 50 * 1024 * 1024) {
                        throw new Error('Archivo demasiado grande. Máximo 50MB.');
                    }
                    
                    const pad = document.querySelector('.pad[data-number="' + padNumber + '"]');
                    if (pad) {
                        pad.classList.add('loading');
                    }
                    
                    const reader = new FileReader();
                    const self = this;
                
                reader.onload = function(e) {
                    self.audioContext.decodeAudioData(e.target.result).then(function(audioBuffer) {
                        self.bankSamples[bank][padNumber] = audioBuffer;
                        
                        if (bank === self.currentBank) {
                            self.samples[padNumber] = audioBuffer;
                        }
                        
                        const fileName = file.name;
                        const nameWithoutExt = fileName.split('.').slice(0, -1).join('.');
                        self.sampleNames[bank][padNumber] = nameWithoutExt;
                        
                        if (pad) {
                            pad.classList.remove('loading');
                            pad.classList.add('loaded');
                            
                            const sampleIndicator = pad.querySelector('.sample-indicator');
                            if (sampleIndicator) {
                                sampleIndicator.textContent = 'Bank ' + bank;
                                sampleIndicator.style.display = 'block';
                            }
                            
                            const nameLabel = pad.querySelector('.sample-name');
                            if (nameLabel) {
                                nameLabel.textContent = nameWithoutExt;
                                nameLabel.style.display = 'block';
                            }
                            
                            const keyboardIndicator = pad.querySelector('.keyboard-indicator');
                            if (keyboardIndicator) {
                                keyboardIndicator.style.display = 'block';
                            }
                            
                            self.showLoadedEffect(pad);
                            
                            // NUEVO: Feedback táctil al cargar sample de usuario
                            self.triggerTactileFeedback('light');
                            self.playTactileSound(800, 0.05);
                        }
                        
                        self.saveSampleInfo();
                        
                        self.updateStatus('✅ "' + nameWithoutExt + '" cargado en Pad ' + padNumber + ' (Banco ' + padNumber + ')');
                    }).catch(function(error) {
                        console.error('Error decodificando audio:', error);
                        
                        if (pad) {
                            pad.classList.remove('loading');
                        }
                        
                        // Mensaje de error más específico
                        let errorMessage = 'Error al procesar el archivo de audio.';
                        if (error.name === 'EncodingError') {
                            errorMessage = 'Formato de audio no soportado o archivo corrupto.';
                        } else if (error.name === 'NotSupportedError') {
                            errorMessage = 'Formato de audio no soportado por el navegador.';
                        }
                        
                        self.updateStatus('❌ ' + errorMessage);
                    });
                };
                
                reader.onerror = function(error) {
                    console.error('Error leyendo archivo:', error);
                    
                    if (pad) {
                        pad.classList.remove('loading');
                    }
                    
                    self.updateStatus('❌ Error al leer el archivo. Verifica que el archivo no esté corrupto.');
                };
                
                reader.readAsArrayBuffer(file);
                
            } catch (error) {
                console.error('Error en loadUserSample:', error);
                
                // Limpiar estado del pad en caso de error
                const pad = document.querySelector('.pad[data-number="' + padNumber + '"]');
                if (pad) {
                    pad.classList.remove('loading');
                }
                
                this.updateStatus('❌ Error: ' + error.message);
            }
            }
            
            loadAllSamples() {
                this.updateStatus('Cargando samples del Banco A...');
                const loadPromises = [];
                const self = this;
                
                audioFiles.forEach(function(file, index) {
                    const padNumber = index + 1;
                    const pad = document.querySelector('.pad[data-number="' + padNumber + '"]');
                    
                    if (pad) {
                        pad.classList.add('loading');
                    }
                    
                    const promise = self.loadAudioForPad(padNumber, file, 'A')
                        .then(function() {
                            if (pad) {
                                pad.classList.remove('loading');
                                pad.classList.add('loaded');
                                
                                const nameWithoutExt = file.split('.').slice(0, -1).join('.');
                                self.sampleNames['A'][padNumber] = nameWithoutExt;
                                
                                self.updatePadBankIndicators();
                                self.showLoadedEffect(pad);
                            }
                        })
                        .catch(function(error) {
                            if (pad) {
                                pad.classList.remove('loading');
                            }
                            console.error('Error cargando sample ' + padNumber + ':', error);
                        });
                    
                    loadPromises.push(promise);
                });
                
                return Promise.allSettled(loadPromises).then(function() {
                    self.saveSampleInfo();
                    return loadPromises;
                });
            }
            
            loadAudioForPad(padNumber, audioName, bank) {
                const self = this;
                bank = bank || 'A';
                
                if (!this.audioContext) return Promise.reject(new Error('Contexto de audio no inicializado'));
                
                const audioUrl = GITHUB_REPO_URL + audioName;
                return fetch(audioUrl)
                    .then(function(response) {
                        if (!response.ok) {
                            throw new Error('HTTP error! status: ' + response.status);
                        }
                        return response.arrayBuffer();
                    })
                    .then(function(arrayBuffer) {
                        return self.audioContext.decodeAudioData(arrayBuffer);
                    })
                    .then(function(audioBuffer) {
                        self.bankSamples[bank][padNumber] = audioBuffer;
                        
                        if (bank === self.currentBank) {
                            self.samples[padNumber] = audioBuffer;
                        }
                        
                        const nameWithoutExt = audioName.split('.').slice(0, -1).join('.');
                        self.sampleNames[bank][padNumber] = nameWithoutExt;
                        
                        self.updateStatus('Audio "' + audioName + '" cargado en el Pad ' + padNumber + ' (Banco ' + bank + ')');
                        
                        // NUEVO: Feedback táctil al cargar sample
                        self.triggerTactileFeedback('light');
                        self.playTactileSound(800, 0.05);
                        
                        return audioBuffer;
                    })
                    .catch(function(error) {
                        self.updateStatus('Error al cargar el audio para el Pad ' + padNumber + ' (Banco ' + bank + ')');
                        throw error;
                    });
            }
            
            recordPadEvent(padNumber) {
                const currentTime = this.audioContext.currentTime;
                const relativeTime = (currentTime - this.sequenceStartTime) % (60 / this.bpm * BEATS_PER_BAR);
                
                this.sequence[this.currentBar].push({
                    pad: padNumber,
                    time: relativeTime,
                    bank: this.currentBank
                });
                
                console.log('Recorded in bar ' + (this.currentBar+1) + ', time: ' + relativeTime.toFixed(2) + 's, bank: ' + this.currentBank);
            }
            
            // VISUALIZADOR DE AUDIO
            visualize(padNumber, analyser, canvas) {
                if (!canvas) return;
                
                const canvasCtx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const bufferLength = analyser.frequencyBinCount;
                const waveformDataArray = new Uint8Array(bufferLength);
                
                if (this.visualizers[padNumber]) {
                    cancelAnimationFrame(this.visualizers[padNumber]);
                }
                
                const padColors = this.getPadColors(padNumber);
                const self = this;
                
                function draw() {
                    self.visualizers[padNumber] = requestAnimationFrame(draw);
                    
                    analyser.getByteTimeDomainData(waveformDataArray);
                    
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        const sample = Math.abs(waveformDataArray[i] - 128);
                        sum += sample;
                    }
                    const average = sum / bufferLength;
                    const energy = average / 128;
                    
                    canvasCtx.clearRect(0, 0, width, height);
                    canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    canvasCtx.fillRect(0, 0, width, height);
                    
                    self.drawWaveform(canvasCtx, waveformDataArray, width, height, padColors, energy);
                }
                
                draw();
            }
            
            drawWaveform(ctx, dataArray, width, height, colors, energy) {
                const bufferLength = dataArray.length;
                const sliceWidth = width / bufferLength;
                
                // Línea central
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();
                
                // Configurar línea principal
                ctx.lineWidth = 2 + energy * 5;
                ctx.strokeStyle = colors.primary;
                ctx.shadowColor = colors.primary;
                ctx.shadowBlur = 10 * energy;
                
                // Dibujar forma de onda principal
                ctx.beginPath();
                
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * height / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        const prevX = x - sliceWidth;
                        const prevY = dataArray[i - 1] / 128.0 * height / 2;
                        const cpx1 = prevX + sliceWidth / 3;
                        const cpx2 = x - sliceWidth / 3;
                        
                        if (Math.abs(y - prevY) > height * 0.1) {
                            ctx.lineTo(x, y);
                        } else {
                            ctx.bezierCurveTo(cpx1, prevY, cpx2, y, x, y);
                        }
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Línea de reflejo
                ctx.lineWidth = 1 + energy * 2;
                ctx.strokeStyle = colors.secondary;
                ctx.globalAlpha = 0.3;
                
                ctx.beginPath();
                x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = height - (v * height / 2);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }
            
            getPadColors(padNumber) {
                return {
                    primary: 'var(--shadow-color-dark)',    // Verde GameBoy oscuro
                    secondary: 'var(--shadow-color-light)'  // Verde GameBoy claro
                };
            }
            
            resizeCanvases() {
                const pads = document.querySelectorAll('.pad');
                pads.forEach(function(pad) {
                    const canvas = pad.querySelector('.visualizer');
                    if (canvas) {
                        canvas.width = pad.offsetWidth;
                        canvas.height = pad.offsetHeight;
                    }
                });
            }
            
            // SAMPLE SLICER
            openSlicerModal(padNumber) {
                if (!this.samples[padNumber]) {
                    this.updateStatus('❌ No hay sample en este pad para cortar');
                    return;
                }
                
                const duration = this.samples[padNumber].duration;
                if (duration < 1) {
                    this.updateStatus('❌ El sample es demasiado corto para cortar');
                    return;
                }
                
                this.slicerSourcePad = padNumber;
                this.slicerSourceBuffer = this.samples[padNumber];
                
                const sampleName = this.sampleNames[this.currentBank][padNumber] || ('Sample ' + padNumber);
                const durationText = duration.toFixed(2) + 's';
                
                const maxSlices = 16 - padNumber + 1;
                let infoText = 'Slice "' + sampleName + '" (' + durationText + ')';
                infoText += '\nSlices desde Pad ' + padNumber;
                
                if (maxSlices < 16) {
                    infoText += ' (máx. ' + maxSlices + ' slices)';
                }
                
                document.getElementById('slicer-info').textContent = infoText;
                this.updateSlicerButtons(maxSlices);
                document.getElementById('slicer-modal').style.display = 'flex';
                
                this.updateStatus('🔪 Slicer abierto para Pad ' + padNumber);
            }
            
            updateSlicerButtons(maxSlices) {
                const buttonsContainer = document.getElementById('slicer-buttons');
                buttonsContainer.innerHTML = '';
                
                const sliceOptions = [
                    { count: 4, label: '4 Slices' },
                    { count: 8, label: '8 Slices' },
                    { count: 16, label: '16 Slices' }
                ];
                
                const self = this;
                sliceOptions.forEach(function(option) {
                    const button = document.createElement('button');
                    button.className = 'slicer-btn';
                    button.textContent = option.label;
                    
                    if (option.count <= maxSlices) {
                        button.onclick = function() { self.applySlicer(option.count); };
                    } else {
                        button.disabled = true;
                        button.style.opacity = '0.5';
                        button.style.cursor = 'not-allowed';
                        button.textContent = option.label + ' (no caben)';
                    }
                    
                    buttonsContainer.appendChild(button);
                });
            }
            
            closeSlicerModal() {
                document.getElementById('slicer-modal').style.display = 'none';
                this.slicerSourcePad = null;
                this.slicerSourceBuffer = null;
                this.updateStatus('🔪 Slicer cancelado');
            }
            
            applySlicer(numSlices) {
                if (!this.slicerSourceBuffer || !this.slicerSourcePad) {
                    this.updateStatus('❌ Error: No hay sample para cortar');
                    return;
                }
                
                try {
                    this.updateStatus('🔪 Cortando en ' + numSlices + ' partes...');
                    
                    const slices = this.createSlices(this.slicerSourceBuffer, numSlices);
                    this.distributeSlices(slices, this.slicerSourcePad);
                    
                    this.closeSlicerModal();
                    
                    const endPad = this.slicerSourcePad + numSlices - 1;
                    
                    // NUEVO: Feedback táctil al crear slices
                    this.triggerTactileFeedback('strong');
                    this.playTactileSound(1000, 0.1);
                    
                    this.updateStatus('✅ ' + numSlices + ' slices: Pads ' + this.slicerSourcePad + '-' + Math.min(endPad, 16));
                    
                } catch (error) {
                    console.error('Error en slicer:', error);
                    this.updateStatus('❌ Error al crear slices');
                }
            }
            
            createSlices(sourceBuffer, numSlices) {
                const slices = [];
                const totalFrames = sourceBuffer.length;
                const framesPerSlice = Math.floor(totalFrames / numSlices);
                const sampleRate = sourceBuffer.sampleRate;
                const numberOfChannels = sourceBuffer.numberOfChannels;
                
                for (let i = 0; i < numSlices; i++) {
                    const startFrame = i * framesPerSlice;
                    const endFrame = Math.min(startFrame + framesPerSlice, totalFrames);
                    const sliceLength = endFrame - startFrame;
                    
                    const sliceBuffer = this.audioContext.createBuffer(
                        numberOfChannels, 
                        sliceLength, 
                        sampleRate
                    );
                    
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const sourceData = sourceBuffer.getChannelData(channel);
                        const sliceData = sliceBuffer.getChannelData(channel);
                        
                        for (let frame = 0; frame < sliceLength; frame++) {
                            sliceData[frame] = sourceData[startFrame + frame];
                        }
                    }
                    
                    slices.push(sliceBuffer);
                }
                
                return slices;
            }
            
            distributeSlices(slices, startPadNumber) {
                const sourcePadName = this.sampleNames[this.currentBank][this.slicerSourcePad] || 
                                     ('Sample ' + this.slicerSourcePad);
                
                const self = this;
                slices.forEach(function(slice, index) {
                    const targetPad = startPadNumber + index;
                    
                    if (targetPad >= 1 && targetPad <= 16) {
                        self.bankSamples[self.currentBank][targetPad] = slice;
                        self.samples[targetPad] = slice;
                        
                        const sliceNumber = (index + 1).toString().padStart(2, '0');
                        const sliceName = sourcePadName + '-' + sliceNumber;
                        self.sampleNames[self.currentBank][targetPad] = sliceName;
                        
                        const pad = document.querySelector('.pad[data-number="' + targetPad + '"]');
                        if (pad) {
                            pad.classList.add('loaded');
                            
                            const sliceIndicator = pad.querySelector('.slice-indicator');
                            if (sliceIndicator) {
                                sliceIndicator.textContent = sliceNumber + '/' + slices.length.toString().padStart(2, '0');
                                sliceIndicator.style.display = 'block';
                            }
                        }
                    }
                });
                
                this.updatePadBankIndicators();
                this.saveSampleInfo();
                
                const usedPads = Math.min(slices.length, 16 - startPadNumber + 1);
                if (usedPads < slices.length) {
                    this.updateStatus('⚠️ Solo se pudieron asignar ' + usedPads + '/' + slices.length + ' slices (no hay suficientes pads)');
                }
            }
            
            // SECUENCIADOR
            createMetronomeSound(isAccented) {
                isAccented = isAccented || false;
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                oscillator.type = 'sine';
                
                oscillator.frequency.setValueAtTime(
                    isAccented ? 880 : 440, 
                    this.audioContext.currentTime
                );
                
                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(
                    isAccented ? 0.2 : 0.1, 
                    this.audioContext.currentTime
                );
                gainNode.gain.exponentialRampToValueAtTime(
                    0.001, 
                    this.audioContext.currentTime + 0.1
                );
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }
            
            createAccentedMetronomeSound() {
                this.createMetronomeSound(true);
            }
            
            startMetronome() {
                if (this.metronomeInterval) {
                    clearInterval(this.metronomeInterval);
                }
                
                const beatDuration = 60000 / this.bpm;
                let tickCount = 0;
                
                this.currentBeat = 1;
                this.currentBar = 0; // Aseguramos que empezamos en el compás 1
                this.updateBarBeatDisplay();
                
                this.createAccentedMetronomeSound();
                
                const self = this;
                this.metronomeInterval = setInterval(function() {
                    tickCount++;
                    
                    // Actualizar el pulso basado en el tick
                    self.currentBeat = (tickCount % BEATS_PER_BAR) + 1;
                    
                    // Actualizar el compás cuando completamos un ciclo de pulsos
                    if (self.currentBeat === 1) {
                        self.currentBar = Math.floor(tickCount / BEATS_PER_BAR) % BAR_COUNT;
                    }
                    
                    // Actualizar la UI
                    self.updateBarBeatDisplay();
                    
                    // Reproducir sonido del metrónomo
                    if (self.currentBeat === 1) {
                        self.createAccentedMetronomeSound();
                    } else {
                        self.createMetronomeSound();
                    }
                }, beatDuration);
            }
            
            stopMetronome() {
                if (this.metronomeInterval) {
                    clearInterval(this.metronomeInterval);
                    this.metronomeInterval = null;
                }
            }
            
            updateBarBeatDisplay() {
                document.getElementById('current-bar').textContent = this.currentBar + 1;
                document.getElementById('current-beat').textContent = this.currentBeat;
            }
            
            startBarAdvancement() {
                if (this.beatInterval) {
                    clearInterval(this.beatInterval);
                }
                
                let totalBarsRecorded = 0;
                let tickCount = 0;
                const self = this;
                const beatDuration = 60000 / this.bpm;
                
                // Inicializar contadores
                this.currentBar = 0;
                this.currentBeat = 1;
                this.updateBarBeatDisplay();
                
                this.beatInterval = setInterval(function() {
                    if (self.isRecording || self.isPlaying) {
                        tickCount++;
                        
                        // Actualizar el pulso basado en el tick
                        self.currentBeat = (tickCount % BEATS_PER_BAR) + 1;
                        document.getElementById('current-beat').textContent = self.currentBeat;
                        
                        // Si completamos un compás
                        if (self.currentBeat === 1) {
                            self.currentBar = Math.floor(tickCount / BEATS_PER_BAR) % BAR_COUNT;
                            document.getElementById('current-bar').textContent = self.currentBar + 1;
                            
                            if (self.isRecording) {
                                totalBarsRecorded++;
                                
                                if (totalBarsRecorded >= BAR_COUNT) {
                                    self.isRecording = false;
                                    self.isPlaying = true;
                                    
                                    self.stopMetronome();
                                    
                                    document.getElementById('record-sequence').textContent = "REC";
                                    document.getElementById('record-sequence').classList.remove('active');
                                    self.updateStatus('Grabación completada. Reproduciendo en loop (sin metrónomo)...');
                                }
                                else {
                                    const statusMsg = 'Grabando compás ' + (self.currentBar + 1) + '... (' + totalBarsRecorded + '/' + BAR_COUNT + ')';
                                    self.updateStatus(statusMsg);
                                }
                            }
                            else if (self.isPlaying) {
                                const statusMsg = 'Reproduciendo compás ' + (self.currentBar + 1) + '...';
                                self.updateStatus(statusMsg);
                                
                                self.playCurrentBar();
                            }
                        }
                    } else {
                        self.stopTimers();
                    }
                }, beatDuration);
            }
            
            toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }
            
            /**
             * Inicia la grabación
             * @method startRecording
             * @description Comienza a grabar una secuencia
             * @throws {Error} Si el audio no está inicializado
             */
            startRecording() {
                if (!this.audioContext) {
                    this.updateStatus('Por favor, inicia el audio antes de grabar.');
                    return;
                }
                
                if (this.moveState.isActive) {
                    this.cancelMoveOperation();
                }
                
                if (this.isPlaying) {
                    this.isPlaying = false;
                    document.getElementById('play-sequence').classList.remove('active');
                }
                
                this.isRecording = true;
                this.sequence = Array(BAR_COUNT).fill().map(function() { return []; });
                this.currentBar = 0;
                this.currentBeat = 1;
                
                const recordBtn = document.getElementById('record-sequence');
                recordBtn.textContent = "STOP";
                recordBtn.classList.add('active');
                this.updateBarBeatDisplay();
                this.updateStatus('Preparando para grabar...');
                
                this.startPrecount();
            }
            
            startPrecount() {
                let preCountRemaining = PRE_COUNT_BARS * BEATS_PER_BAR;
                this.startMetronome();
                
                const self = this;
                function preCount() {
                    if (preCountRemaining > 0) {
                        self.updateStatus('Pre-conteo: ' + Math.ceil(preCountRemaining / BEATS_PER_BAR));
                        preCountRemaining--;
                        setTimeout(preCount, 60000 / self.bpm);
                    } else {
                        self.sequenceStartTime = self.audioContext.currentTime;
                        self.updateStatus('Grabando secuencia...');
                        self.startBarAdvancement();
                    }
                }
                
                preCount();
            }
            
            stopRecording() {
                this.isRecording = false;
                this.stopTimers();
                const recordBtn = document.getElementById('record-sequence');
                recordBtn.textContent = "REC";
                recordBtn.classList.remove('active');
                this.updateStatus('Grabación detenida');
            }
            
            playSequence() {
                if (this.isPlaying) return;
                
                if (!this.audioContext) {
                    this.updateStatus('Por favor, inicia el audio antes de reproducir.');
                    return;
                }
                
                if (this.moveState.isActive) {
                    this.cancelMoveOperation();
                }
                
                const hasSequenceData = this.sequence.some(function(bar) { return bar.length > 0; });
                if (!hasSequenceData) {
                    this.updateStatus('No hay secuencia grabada para reproducir.');
                    return;
                }
                
                this.isPlaying = true;
                this.currentBar = 0;
                this.currentBeat = 1;
                this.updateBarBeatDisplay();
                
                document.getElementById('play-sequence').classList.add('active');
                this.sequenceStartTime = this.audioContext.currentTime;
                this.updateStatus('Reproduciendo secuencia (sin metrónomo)');
                
                this.startBarAdvancement();
                this.playCurrentBar();
            }
            
            playCurrentBar() {
                if (!this.isPlaying) return;
                
                const self = this;
                this.sequence[this.currentBar].forEach(function(event) {
                    setTimeout(function() {
                        if (self.isPlaying) {
                            if (event.bank && event.bank !== self.currentBank) {
                                const originalBank = self.currentBank;
                                self.selectBank(event.bank);
                                
                                self.playPad(event.pad);
                                
                                setTimeout(function() {
                                    self.selectBank(originalBank);
                                }, 100);
                            } else {
                                self.playPad(event.pad);
                            }
                        }
                    }, event.time * 1000);
                });
            }
            
            stopSequence() {
                this.isPlaying = false;
                this.stopTimers();
                
                if (this.moveState.isActive) {
                    this.cancelMoveOperation();
                }
                
                document.getElementById('play-sequence').classList.remove('active');
                this.updateStatus('Secuencia detenida');
            }
            
            clearSequence() {
                this.sequence = Array(BAR_COUNT).fill().map(function() { return []; });
                this.currentBar = 0;
                this.updateBarBeatDisplay();
                this.updateStatus('Secuencia borrada');
            }
            
            // NUEVO: Mostrar selector de pad para slicer
            showPadSelectorForSlicer() {
                if (!this.audioContext) {
                    this.updateStatus('❌ Por favor, inicia el audio antes de usar el slicer.');
                    return;
                }
                
                // Encontrar el primer pad con sample
                let firstPadWithSample = null;
                for (let i = 1; i <= 16; i++) {
                    if (this.samples[i]) {
                        firstPadWithSample = i;
                        break;
                    }
                }
                
                if (!firstPadWithSample) {
                    this.updateStatus('❌ No hay samples cargados para usar el slicer.');
                    return;
                }
                
                // Abrir slicer en el primer pad disponible
                this.openSlicerModal(firstPadWithSample);
                
                this.updateStatus('🔪 Slicer abierto para Pad ' + firstPadWithSample + '. Doble clic en cualquier pad para cambiar.');
            }

            // NUEVO: Feedback táctil (vibración)
            triggerTactileFeedback(intensity = 'medium') {
                if (!TACTILE_FEEDBACK_ENABLED) return;
                
                try {
                    if (navigator.vibrate) {
                        let duration;
                        switch (intensity) {
                            case 'light': duration = 10; break;
                            case 'medium': duration = 20; break;
                            case 'strong': duration = 30; break;
                            default: duration = 20;
                        }
                        navigator.vibrate(duration);
                    }
                } catch (error) {
                    console.log('Vibración no disponible:', error);
                }
            }

            // NUEVO: Feedback táctil (sonido sutil)
            playTactileSound(frequency = 800, duration = 0.05) {
                if (!TACTILE_FEEDBACK_ENABLED || !this.audioContext) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                } catch (error) {
                    console.log('Sonido táctil no disponible:', error);
                }
            }

            // NUEVO: Detectar gestos de swipe
            initSwipeDetection() {
                let startX = 0;
                let startY = 0;
                let startTime = 0;
                let isSwiping = false;

                const handleTouchStart = (e) => {
                    if (e.touches.length !== 1) return;
                    
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    startTime = Date.now();
                    isSwiping = false;
                };

                const handleTouchMove = (e) => {
                    if (!startTime || e.touches.length !== 1) return;
                    
                    const currentX = e.touches[0].clientX;
                    const currentY = e.touches[0].clientY;
                    const deltaX = currentX - startX;
                    const deltaY = currentY - startY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (distance > SWIPE_THRESHOLD && !isSwiping) {
                        isSwiping = true;
                        
                        // Determinar dirección del swipe
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            // Swipe horizontal
                            if (deltaX > 0) {
                                this.handleSwipeRight();
                            } else {
                                this.handleSwipeLeft();
                            }
                        } else {
                            // Swipe vertical
                            if (deltaY > 0) {
                                this.handleSwipeDown();
                            } else {
                                this.handleSwipeUp();
                            }
                        }
                        
                        // Feedback táctil
                        this.triggerTactileFeedback('medium');
                        this.playTactileSound(600, 0.08);
                        
                        // Mostrar indicador de swipe
                        this.showSwipeIndicator();
                    }
                };

                const handleTouchEnd = () => {
                    startTime = 0;
                    isSwiping = false;
                };

                // Agregar event listeners para swipe
                document.addEventListener('touchstart', handleTouchStart, { passive: true });
                document.addEventListener('touchmove', handleTouchMove, { passive: true });
                document.addEventListener('touchend', handleTouchEnd, { passive: true });
            }

            // NUEVO: Manejadores de swipe
            handleSwipeLeft() {
                // Cambiar al bank anterior
                const banks = ['A', 'B', 'C', 'D'];
                const currentIndex = banks.indexOf(this.currentBank);
                if (currentIndex > 0) {
                    this.currentBank = banks[currentIndex - 1];
                    this.selectBank(this.currentBank);
                    this.updateStatus('🔄 Bank ' + this.currentBank + ' cargado');
                    this.triggerTactileFeedback('light');
                }
            }

            handleSwipeRight() {
                // Cambiar al bank siguiente
                const banks = ['A', 'B', 'C', 'D'];
                const currentIndex = banks.indexOf(this.currentBank);
                if (currentIndex < 3) {
                    this.currentBank = banks[currentIndex + 1];
                    this.selectBank(this.currentBank);
                    this.updateStatus('🔄 Bank ' + this.currentBank + ' cargado');
                    this.triggerTactileFeedback('light');
                }
            }

            handleSwipeUp() {
                // Aumentar BPM
                if (this.bpm < 200) {
                    this.bpm = Math.min(200, this.bpm + 5);
                    document.getElementById('tempo-display').textContent = this.bpm + ' BPM';
                    this.updateStatus('⚡ BPM: ' + this.bpm);
                    this.triggerTactileFeedback('light');
                }
            }

            handleSwipeDown() {
                // Disminuir BPM
                if (this.bpm > 60) {
                    this.bpm = Math.max(60, this.bpm - 5);
                    document.getElementById('tempo-display').textContent = this.bpm + ' BPM';
                    this.updateStatus('⚡ BPM: ' + this.bpm);
                    this.triggerTactileFeedback('light');
                }
            }
            
            // NUEVO: Mostrar/ocultar indicador de swipe
            showSwipeIndicator() {
                const indicator = document.getElementById('swipe-indicator');
                if (indicator) {
                    indicator.style.display = 'block';
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 2000);
                }
            }


        }
        
        // INICIALIZACIÓN DE LA APLICACIÓN
        document.addEventListener('DOMContentLoaded', function() {
            window.embryoPlayer = new EmbrioPlayer();
            
            // LOG DE INICIALIZACIÓN
            console.log('🎵 Embrio Player v3.0 - Enhanced Version Iniciado');
            console.log('✨ Nuevas características:');
            console.log('   - Long Press BPM (cambios rápidos cada 200ms)');
            console.log('   - Sistema de entrada múltiple (Mouse + Touch + Teclado + MIDI)');
            console.log('   - Mapeo de teclado: QWER/ASDF/ZXCV/1234 → Pads 1-16');
            console.log('   - Indicadores de método de entrada activo');
            console.log('   - Feedback visual mejorado');
            console.log('   - Sistema unificado de control de pads');
            console.log('   - Feedback táctil (vibración + sonidos sutiles)');
            console.log('   - Gestos de swipe para navegación (←→ Banks, ↑↓ BPM)');
            console.log('   - Botón táctil para slicer móvil');
            console.log('🎛️ Listo para usar - Inicia el audio para comenzar');
        });
    </script>
</body>
</html>